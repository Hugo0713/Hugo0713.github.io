<!doctypehtml><html lang=zh-CN><meta charset=UTF-8><meta content=width=device-width,initial-scale=1,maximum-scale=2 name=viewport><meta content=#222 name=theme-color><meta content="Hexo 7.3.0" name=generator><link href=/images/apple-touch-icon-next.png rel=apple-touch-icon sizes=180x180><link href=/images/favicon-32x32-next.png rel=icon sizes=32x32 type=image/png><link href=/images/favicon-16x16-next.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><link href=/css/main.css rel=stylesheet><link href=/lib/font-awesome/css/all.min.css rel=stylesheet><link href=/lib/pace/pace-theme-material.min.css rel=stylesheet><script src=/lib/pace/pace.min.js></script><script id=hexo-configurations>var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":280,"display":"post","padding":18,"offset":15,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#29c6c0","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":false,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};</script><meta content=算法总复习，包含分治，图算法，动态规划，线性规划，P与NP，规约等重点知识的总结。 name=description><meta content=article property=og:type><meta content="Algorithm：Overall Review" property=og:title><meta content=http://example.com/2025/06/07/Math/Algorithm/index.html property=og:url><meta content="Hugo's Cyber Heritage" property=og:site_name><meta content=算法总复习，包含分治，图算法，动态规划，线性规划，P与NP，规约等重点知识的总结。 property=og:description><meta content=zh_CN property=og:locale><meta content=http://example.com/images/image_64.png property=og:image><meta content=http://example.com/images/image_65.png property=og:image><meta content=http://example.com/images/image_66.png property=og:image><meta content=http://example.com/images/image_67.png property=og:image><meta content=2025-06-07T12:37:42.000Z property=article:published_time><meta content=2025-06-15T14:11:01.079Z property=article:modified_time><meta content=Hugo property=article:author><meta content=Algorithm property=article:tag><meta content=summary name=twitter:card><meta content=http://example.com/images/image_64.png name=twitter:image><link href=http://example.com/2025/06/07/Math/Algorithm/ rel=canonical><script id=page-configurations>// https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };</script><title>Algorithm：Overall Review | Hugo's Cyber Heritage</title><noscript><style>.use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }</style></noscript><!-- hexo injector head_end start --><style>.s {
    background-color: #000;
    color: #000;
    padding: 0 3px;
    cursor: pointer;
    user-select: none;
  }
  .s.revealed {
    background-color: transparent;
    color: inherit;
  }</style><!-- hexo injector head_end end --><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}</style><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style><body itemscope itemtype=http://schema.org/WebPage><div class="container use-motion"><div class=headband></div><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <span class=logo-line-before><i></i></span> <h1 class=site-title>Hugo's Cyber Heritage</h1> <span class=logo-line-after><i></i></span> </a><p class=site-subtitle itemprop=description>Shine or Die</div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu" id=menu><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-about"><a href=/about/ rel=section><i class="fa fa-user fa-fw"></i>关于</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类<span class=badge>12</span></a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签<span class=badge>34</span></a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档<span class=badge>60</span></a><li class="menu-item menu-item-resources"><a href=/resources/ rel=section><i class="fa fa-book fa-fw"></i>资源</a><li class="menu-item menu-item-contact"><a href=/contact/ rel=section><i class="fa fa-envelope fa-fw"></i>联系</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container><input autocapitalize=off autocomplete=off class=search-input placeholder=搜索... spellcheck=false type=search></div><span class=popup-btn-close> <i class="fa fa-times-circle"></i> </span></div><div id=search-result><div id=no-result><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class=reading-progress-bar></div><a class="book-mark-link book-mark-link-fixed" role=button></a><a aria-label="Follow me on GitHub" title="Follow me on GitHub" class=github-corner href=https://github.com/hugo0713 rel=noopener target=_blank><svg viewbox="0 0 250 250" aria-hidden=true height=80 width=80><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" style="transform-origin: 130px 106px;" class=octo-arm fill=currentColor></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" class=octo-body fill=currentColor></path></svg></a><main class=main><div class=main-inner><div class=content-wrap><div class="content post posts-expand"><article class=post-block itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=http://example.com/2025/06/07/Math/Algorithm/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/images/avatar.png itemprop=image> <meta content=Hugo itemprop=name> <meta content=古之成大事者，不惟有超世之才，亦必有坚韧不拔之志。 itemprop=description> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content="Hugo's Cyber Heritage" itemprop=name> </span><header class=post-header><h1 itemprop="name headline" class=post-title>Algorithm：Overall Review</h1><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2025-06-07 20:37:42" datetime=2025-06-07T20:37:42+08:00>2025-06-07</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2025-06-15 22:11:01" datetime=2025-06-15T22:11:01+08:00 itemprop=dateModified>2025-06-15</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/MATH/ itemprop=url rel=index><span itemprop=name>MATH</span></a> </span> </span><span style="display: none;" class=post-meta-item id=busuanzi_container_page_pv title=阅读次数> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=post-meta-item-text>阅读次数：</span> <span id=busuanzi_value_page_pv></span> </span><br><span class=post-meta-item title=本文字数> <span class=post-meta-item-icon> <i class="far fa-file-word"></i> </span> <span class=post-meta-item-text>本文字数：</span> <span>282</span> </span><span class=post-meta-item title=阅读时长> <span class=post-meta-item-icon> <i class="far fa-clock"></i> </span> <span class=post-meta-item-text>阅读时长 ≈</span> <span>1 分钟</span> </span></div></header><div class=post-body itemprop=articleBody><p>算法总复习，包含分治，图算法，动态规划，线性规划，P与NP，规约等重点知识的总结。<br><span id=more></span><h2 id=Divide-and-Conquer><a title="Divide and Conquer" class=headerlink href=#Divide-and-Conquer></a>Divide and Conquer</h2><h3 id=Master-theorem><a title="Master theorem:" class=headerlink href=#Master-theorem></a><strong>Master theorem:</strong></h3><script type="math/tex; mode=display">T(n)=a T(\lceil n / b\rceil)+O\left(n^{d}\right)</script><p>for some constants (a>0) , (b>1) ,and (d ≥0) , then</p><script type="math/tex; mode=display">T(n)= \begin{cases}O\left(n^{d}\right) & if d>log _{b} a \\ O\left(n^{d} log n\right) & if d=log _{b} a \\ O\left(n^{log _{b} a}\right) & if d<log _{b} a .\end{cases}</script><p>d代表非递归部分（即每次递归调用之外的操作）的时间复杂度的指数。<p>证明：分析递归树的总工作量</p><script type="math/tex; mode=display">T(n) = \sum_{k=0}^{\log_b n} n^d \cdot r^k = n^d \sum_{k=0}^{\log_b n} (\frac{a}{b^d})^k</script><h3 id=FFT><a class=headerlink href=#FFT title=FFT></a>FFT</h3><h2 id=Graph-Algorithms><a title="Graph Algorithms" class=headerlink href=#Graph-Algorithms></a>Graph Algorithms</h2><h3 id=DFS><a class=headerlink href=#DFS title=DFS></a>DFS</h3><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line>EXPLORE(G, v):  </span><br><span class=line>1. visited[v] = true  </span><br><span class=line>2. pre[v] = clock; clock++      # 记录发现时间  </span><br><span class=line>3. for each edge (v, u) ∈ E:  </span><br><span class=line>4.    if not visited[u]:  </span><br><span class=line>5.        EXPLORE(G, u)  </span><br><span class=line>6. post[v] = clock; clock++     # 记录离开时间  </span><br><span class=line></span><br><span class=line>DFS(G):  </span><br><span class=line>1. for all v ∈ V: visited[v] = false  </span><br><span class=line>2. clock = 0  </span><br><span class=line>3. for all v ∈ V:  </span><br><span class=line>4.    if not visited[v]:  </span><br><span class=line>5.        EXPLORE(G, v)  </span><br></pre></table></figure><p>running time：O(|V|+|E|)<h3 id=SCC-（强连通分量）><a title="SCC （强连通分量）" class=headerlink href=#SCC-（强连通分量）></a>SCC （强连通分量）</h3><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line>Input: 有向图 G = (V, E)</span><br><span class=line>Output: G 的强连通分量</span><br><span class=line>1. DFS(G)  # 执行 DFS，记录每个节点的 post 时间</span><br><span class=line>2. 按 post 时间降序排列 V</span><br><span class=line>3. G' = G 的转置图 （将所有边反向）</span><br><span class=line>4. visited = false for all v ∈ V</span><br><span class=line>5. for each v in V (按 post 时间降序):</span><br><span class=line>6.    if not visited[v]:</span><br><span class=line>7.        SCC = {}  # 当前强连通分量</span><br><span class=line>8.        EXPLORE(G', v)  # 在转置图上进行 DFS</span><br><span class=line>9.        for each u in SCC:</span><br><span class=line>10.           visited[u] = true  # 标记已访问</span><br><span class=line>11.           print(u)  # 输出当前强连通分量的节点</span><br></pre></table></figure><p>running time：O(|V|+|E|)<h3 id=Dijkstra><a class=headerlink href=#Dijkstra title=Dijkstra></a>Dijkstra</h3><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line>**Input**: 图 G, 边权 ℓ, 起点 s  </span><br><span class=line>**Output**: 所有节点到 s 的最短距离 dist[]  </span><br><span class=line></span><br><span class=line>1. for each u ∈ V:  </span><br><span class=line>2.    dist[u] = ∞; prev[u] = nil  </span><br><span class=line>3. dist[s] = 0  </span><br><span class=line>4. H = 优先队列 (key=dist)   # 初始包含所有节点  </span><br><span class=line>5. while H 非空:  </span><br><span class=line>6.    u = H.deletemin()     # 取出 dist 最小的节点  </span><br><span class=line>7.    for each 边 (u, v) ∈ E:  </span><br><span class=line>8.        if dist[v] > dist[u] + ℓ(u, v):  </span><br><span class=line>9.            dist[v] = dist[u] + ℓ(u, v)  </span><br><span class=line>10.           prev[v] = u  </span><br><span class=line>11.           H.decreasekey(v)  # 更新 v 在队列中的优先级  </span><br></pre></table></figure><h3 id=Bellman-Ford><a class=headerlink href=#Bellman-Ford title=Bellman-Ford></a>Bellman-Ford</h3><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line>**Input**: 图 G, 边权 ℓ, 起点 s（无负环）  </span><br><span class=line>**Output**: 最短距离 dist[]，或报告负环  </span><br><span class=line></span><br><span class=line>1. for each u ∈ V:  </span><br><span class=line>2.    dist[u] = ∞; prev[u] = nil  </span><br><span class=line>3. dist[s] = 0  </span><br><span class=line>4. repeat |V| - 1 次:  </span><br><span class=line>5.    for each 边 e = (u, v) ∈ E:  </span><br><span class=line>6.        if dist[v] > dist[u] + ℓ(u, v):  </span><br><span class=line>7.            dist[v] = dist[u] + ℓ(u, v)  </span><br><span class=line>8.            prev[v] = u  </span><br><span class=line>9. for each 边 e = (u, v) ∈ E:  </span><br><span class=line>10.   if dist[v] > dist[u] + ℓ(u, v):  </span><br><span class=line>11.       return "存在负环"  </span><br></pre></table></figure><p>running time：O(|V| * |E|)<h3 id=DAG-最短路><a title="DAG 最短路" class=headerlink href=#DAG-最短路></a>DAG 最短路</h3><p>拓扑顺序是指在有向无环图（DAG）中，所有边 (u, v) 都满足 u 在 v 之前的线性序列。<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line>Input: DAG G, 边权 ℓ, 起点 s  </span><br><span class=line>Output: 最短距离 dist[]  </span><br><span class=line></span><br><span class=line>1. for each u ∈ V:  </span><br><span class=line>2.    dist[u] = ∞; prev[u] = nil  </span><br><span class=line>3. dist[s] = 0  </span><br><span class=line>4. L = 拓扑排序(G)   # 按线性序排列节点  </span><br><span class=line>5. for each u ∈ L (按序处理):  </span><br><span class=line>6.    for each 边 (u, v) ∈ E:  </span><br><span class=line>7.        if dist[v] > dist[u] + ℓ(u, v):  </span><br><span class=line>8.            dist[v] = dist[u] + ℓ(u, v)  </span><br><span class=line>9.            prev[v] = u  </span><br></pre></table></figure><p>running time: O(|V| + |E|)<h3 id=MST-（最小生成树）><a title="MST （最小生成树）" class=headerlink href=#MST-（最小生成树）></a>MST （最小生成树）</h3><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line>Kruskal(G)</span><br><span class=line>// Input: 无向图 G = (V, E)</span><br><span class=line>// Output: 最小生成树 T</span><br><span class=line>1. T = ∅  // 初始化最小生成树</span><br><span class=line>2. for each edge (u, v) ∈ E in increasing order of weight:</span><br><span class=line>3.    if u and v are in different components:</span><br><span class=line>4.        T = T ∪ {(u, v)}  // 添加边到最小生成树</span><br><span class=line>5.        union(u, v)  // 合并 u 和 v 的连通分量</span><br><span class=line></span><br><span class=line>Prim(G, s)</span><br><span class=line>// Input: 无向图 G = (V, E), 起点 s</span><br><span class=line>// Output: 最小生成树 T</span><br><span class=line>1. T = ∅  // 初始化最小生成树</span><br><span class=line>2. for each vertex v ∈ V: dist[v] = ∞; prev[v] = nil</span><br><span class=line>3. dist[s] = 0  // 起点到自身的距离为 0</span><br><span class=line>4. H = 优先队列 (key=dist)  // 初始化优先队列</span><br><span class=line>5. while H 非空:</span><br><span class=line>6.    u = H.deletemin()  // 取出距离最小的节点</span><br><span class=line>7.    for each 边 (u, v) ∈ E:</span><br><span class=line>8.        if dist[v] > ℓ(u, v):  // 如果找到更小的边</span><br><span class=line>9.            dist[v] = ℓ(u, v)  // 更新距离</span><br><span class=line>10.           prev[v] = u  // 更新前驱节点</span><br><span class=line>11.           H.decreasekey(v)  // 更新优先队列中的优先级</span><br></pre></table></figure><p>切割性质：对于图G的任意切割(S, V-S)，连接S和V-S的最小权重边必然在某个MST中。<br><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line>并查集</span><br><span class=line></span><br><span class=line># 初始化单元素集合  </span><br><span class=line>makeset(x):  </span><br><span class=line>1. π[x] = x      # 父指针  </span><br><span class=line>2. rank[x] = 0   # 秩  </span><br><span class=line></span><br><span class=line># 查找根（带路径压缩）  </span><br><span class=line>find(x):  </span><br><span class=line>1. if x ≠ π[x]:  </span><br><span class=line>2.   π[x] = find(π[x])  # 递归压缩路径  </span><br><span class=line>3. return π[x]  </span><br><span class=line></span><br><span class=line># 合并集合（按秩合并）  </span><br><span class=line>union(x,y):  </span><br><span class=line>1. rx = find(x), ry = find(y)  </span><br><span class=line>2. if rx == ry: return  </span><br><span class=line>3. if rank[rx] > rank[ry]:  </span><br><span class=line>4.   π[ry] = rx  </span><br><span class=line>5. else:  </span><br><span class=line>6.   π[rx] = ry  </span><br><span class=line>7.   if rank[rx] == rank[ry]:  </span><br><span class=line>8.     rank[ry]++  </span><br></pre></table></figure><h2 id=Dynamic-Programming><a title="Dynamic Programming" class=headerlink href=#Dynamic-Programming></a>Dynamic Programming</h2><h3 id=动态规划（Dynamic-Programming）><a title="动态规划（Dynamic Programming）" class=headerlink href=#动态规划（Dynamic-Programming）></a><strong>动态规划（Dynamic Programming）</strong></h3><ul><li><strong>核心思想</strong>：将问题分解为重叠子问题，存储子问题解避免重复计算。<li><strong>关键步骤</strong>： <ol><li>定义子问题<li>建立递推关系（状态转移方程）<li>确定计算顺序（自底向上或记忆化搜索）</ol><li><strong>应用场景</strong>： <ul><li><strong>最长递增子序列 (LIS)</strong>：以 j 结尾的 LIS 长度 <script type=math/tex>L(j) = 1 + \max\{L(i) \mid i < j, a_i < a_j\}</script><li><strong>编辑距离</strong>：字符串对齐的最小差异代价，<script type=math/tex>E(i,j) = \min\{1+E(i-1,j), 1+E(i,j-1), \text{diff}(i,j)+E(i-1,j-1)\}</script><li><strong>背包问题</strong>： <ul><li><strong>重复背包</strong>：<script type=math/tex>K(w) = \max_{i} \{K(w - w_i) + v_i\}</script><li><strong>01 背包</strong>：<script type=math/tex>K(w,j) = \max \{K(w-w_j, j-1) + v_j, K(w, j-1)\}</script></ul><li><strong>矩阵链乘法</strong>：最小化乘法次数，<script type=math/tex>C(i,j) = \min_{k} \{C(i,k) + C(k+1,j) + m_{i-1}m_k m_j\}</script><li><strong>旅行商问题 (TSP)</strong>：C(S,j) 为通过集合 S 以 j 结尾的最短路径，复杂度 O(n^2 2^n)。<li><strong>树上的独立集</strong>：最大独立集大小 <script type=math/tex>l(u) = \max \{1 + \sum \text{grandchildren } l(w), \sum \text{children } l(w) \}</script></ul></ul><h3 id=LIS（最长递增子序列）><a class=headerlink href=#LIS（最长递增子序列） title=LIS（最长递增子序列）></a>LIS（最长递增子序列）</h3><figure class="highlight markdown"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line>Input: 序列 a[1..n]  </span><br><span class=line>Output: LIS 长度  </span><br><span class=line></span><br><span class=line><span class=bullet>1.</span> for j = 1 to n:  </span><br><span class=line><span class=bullet>2.</span>   L[j] = 1  # 初始化以 j 结尾的 LIS 长度  </span><br><span class=line><span class=bullet>3.</span>   for i = 1 to j-1:  </span><br><span class=line><span class=bullet>4.</span>     if a[i] < a[j]:  </span><br><span class=line><span class=bullet>5.</span>       L[j] = max(L[j], L[i] + 1)  </span><br><span class=line><span class=bullet>6.</span> return max(L)  </span><br></pre></table></figure><p>running time: O(n^2)<h3 id=LCS-最长公共子序列><a class=headerlink href=#LCS-最长公共子序列 title=LCS(最长公共子序列)></a>LCS(最长公共子序列)</h3><figure class="highlight markdown"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line>Input: 序列 a[1..n], b[1..m]</span><br><span class=line>Output: LCS 长度</span><br><span class=line><span class=bullet>1.</span> for i = 0 to n: L[i,0] = 0  # 初始化第一行</span><br><span class=line><span class=bullet>2.</span> for j = 0 to m: L[0,j] = 0  # 初始化第一列</span><br><span class=line><span class=bullet>3.</span> for i = 1 to n:</span><br><span class=line><span class=bullet>4.</span>   for j = 1 to m:</span><br><span class=line><span class=bullet>5.</span>     if a[i] == b[j]:</span><br><span class=line><span class=bullet>6.</span>       L[i,j] = L[i-1,j-1] + 1  # 匹配时长度加1</span><br><span class=line><span class=bullet>7.</span>     else:</span><br><span class=line><span class=bullet>8.</span>       L[i,j] = max(L[i-1,j], L[i,j-1])  # 不匹配时取最大</span><br><span class=line><span class=bullet>9.</span> return L[n,m]  # 返回 LCS 长度</span><br></pre></table></figure><p>running time: O(n*m)<h3 id=01背包问题><a class=headerlink href=#01背包问题 title=01背包问题></a>01背包问题</h3><figure class="highlight markdown"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line>Input: 物品重量 w[1..n], 价值 v[1..n], 容量 W  </span><br><span class=line>Output: 最大价值  </span><br><span class=line></span><br><span class=line><span class=bullet>1.</span> for w = 0 to W: K[w,0] = 0  </span><br><span class=line><span class=bullet>2.</span> for j = 1 to n:  </span><br><span class=line><span class=bullet>3.</span>   for w = 1 to W:  </span><br><span class=line><span class=bullet>4.</span>     if w<span class=emphasis>_j > w:  </span></span><br><span class=line><span class=emphasis>5.       K[w,j] = K[w,j-1]  </span></span><br><span class=line><span class=emphasis>6.     else:  </span></span><br><span class=line><span class=emphasis>7.       K[w,j] = max(K[w-w_</span>j,j-1] + v<span class=emphasis>_j, K[w,j-1])  </span></span><br><span class=line><span class=emphasis>8. return K[W,n]  </span></span><br></pre></table></figure><h2 id=Linear-Programming><a title="Linear Programming" class=headerlink href=#Linear-Programming></a>Linear Programming</h2><h3 id=MAX-Flow><a title="MAX Flow" class=headerlink href=#MAX-Flow></a>MAX Flow</h3><figure class="highlight markdown"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line>FORD-FULKERSON(G, s, t):</span><br><span class=line><span class=code>    for each edge (u,v) in G:</span></span><br><span class=line><span class=code>        f(u,v) = 0  // 初始化流量</span></span><br><span class=line><span class=code>    while exists path p from s to t in residual graph G_f:</span></span><br><span class=line><span class=code>        c_f(p) = min{ c_f(u,v) | (u,v) in p }  // 路径剩余容量</span></span><br><span class=line><span class=code>        for each edge (u,v) in p:</span></span><br><span class=line><span class=code>            if (u,v) is forward edge:</span></span><br><span class=line><span class=code>                f(u,v) += c_f(p)</span></span><br><span class=line><span class=code>            else:  // (v,u)是反向边</span></span><br><span class=line><span class=code>                f(v,u) -= c_f(p)  // 减少正向流量</span></span><br><span class=line><span class=code>    return f  // 最大流</span></span><br></pre></table></figure><p>Ford-Fulkerson思想：<ul><li>构建残差图：正向边剩余容量 = c_e - f_e，反向边容量 = f_e<li>迭代寻找增广路径：在残差图中用BFS/DFS找s→t路径<li>更新流量：增加路径上最小残差容量的流量<li>复杂度：O(|V|·|E|²)</ul><p>Max Flow-Min Cut 定理：最大流等于最小割，即在流网络中，源点到汇点的最大流量等于将网络分割成两部分时，割边的最小容量。<p>二分图匹配可以通过归约到最大流算法解决，将二分图转化为流网络，源点连接到左侧节点，右侧节点连接到汇点，边的容量为1。<h3 id=Simplex><a class=headerlink href=#Simplex title=Simplex></a>Simplex</h3><h3 id=Dual-LP><a title="Dual LP" class=headerlink href=#Dual-LP></a>Dual LP</h3><p><img alt="Dual LP" src=/images/image_64.png><h2 id=P-vs-NP><a title="P vs NP" class=headerlink href=#P-vs-NP></a>P vs NP</h2><p><strong>P类问题</strong>：<ul><li>存在多项式时间算法可以求解的决策问题<li>时间复杂度为 O(n^k)，其中 k 是常数</ul><p><strong>NP类问题</strong>：<ul><li>给定一个解，可以在多项式时间内验证其正确性的决策问题<li>Nondeterministic Polynomial time</ul><p><strong>NP-Complete问题</strong>：<ul><li>属于 NP 类的问题<li>NP 类中的任何问题都可以在多项式时间内规约到它<li>如果任何一个 NP-Complete 问题有多项式时间算法，则 P = NP</ul><h3 id=NP-Complete><a class=headerlink href=#NP-Complete title=NP-Complete></a>NP-Complete</h3><p>Search Problem: 给定实例 I 和解验证器 C(I,S)（多项式时间验证），寻找解 S<p>搜索问题等价于NP问题。<div class=table-container><table><thead><tr><th><strong>问题</strong><th><strong>描述</strong><th><strong>对比的 P 类问题</strong><tbody><tr><td><strong>3SAT</strong><td>三变量子句的可满足性<td>2SAT（二变量子句）<tr><td><strong>TSP</strong><td>旅行商问题（最小代价环游）<td>最小生成树<tr><td><strong>LONGEST PATH</strong><td>图中最长简单路径<td>最短路径<tr><td><strong>3D MATCHING</strong><td>三集合匹配（男-女-宠物）<td>二分图匹配<tr><td><strong>KNAPSACK</strong><td>背包问题（整数权重/价值）<td>单位权重背包（动态规划）<tr><td><strong>INDEPENDENT SET</strong><td>图中独立集（无相连顶点）<td>树上的独立集<tr><td><strong>ILP</strong><td>整数线性规划<td>线性规划（单纯形法）</table></div><h2 id=Reductions><a class=headerlink href=#Reductions title=Reductions></a>Reductions</h2><p>A -> B （A不比B更难， A <= B）<br><img alt=Reduction src=/images/image_65.png><br>要点：<ul><li>实例转换<li>解转换（无解传递）<li>均在多项式时间内完成</ul><p>对于非搜索问题，只需要进行实例转换。<h3 id=规约链分析：3SAT-→-INDEPENDENT-SET-→-VERTEX-COVER-→-CLIQUE><a title="规约链分析：3SAT → INDEPENDENT SET → VERTEX COVER → CLIQUE" class=headerlink href=#规约链分析：3SAT-→-INDEPENDENT-SET-→-VERTEX-COVER-→-CLIQUE></a><strong>规约链分析：3SAT → INDEPENDENT SET → VERTEX COVER → CLIQUE</strong></h3><h4 id=1-3SAT-→-INDEPENDENT-SET（独立集）><a title="1. 3SAT → INDEPENDENT SET（独立集）" class=headerlink href=#1-3SAT-→-INDEPENDENT-SET（独立集）></a><strong>1. 3SAT → INDEPENDENT SET（独立集）</strong></h4><ul><li><strong>目标</strong>：将布尔可满足性问题（3SAT）规约到独立集问题。<li><p><strong>步骤</strong>：<br>a. <strong>实例转换</strong>：</p> <ul><li>对包含 k 个子句的 3SAT 公式，构造图 G： <ul><li>每个子句对应一个三角形（3 个顶点），顶点表示子句中的文字（如 <script type=math/tex>x, \neg y</script>）。<li>添加冲突边：若文字互补（如 x 和 <mjx-container class=MathJax jax=SVG><svg style="vertical-align: -0.025ex;" viewbox="0 -442 1239 453" focusable=false height=1.025ex role=img width=2.803ex xmlns=http://www.w3.org/2000/svg><g fill=currentColor stroke=currentColor stroke-width=0 transform=scale(1,-1)><g data-mml-node=math><g data-mml-node=mi><path d="M56 323T56 336T70 356H596Q603 353 611 343V102Q598 89 591 89Q587 89 584 90T579 94T575 98T572 102L571 209V316H70Q56 323 56 336Z" data-c=AC></path></g><g data-mml-node=mi transform=translate(667,0)><path d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z" data-c=1D465></path></g></g></g></svg></mjx-container>），则在所有三角形间连接它们。</ul><li>设独立集目标大小 g = k（子句数）。<br><em>示例</em>：公式 <script type=math/tex>(x \lor y \lor z) \land (\neg x \lor \neg y)</script><br>→ 两个三角形：<script type=math/tex>{x,y,z} 和 {\neg x, \neg y, \text{dummy}}</script>，添加边 <script type=math/tex>(x, \neg x), (y, \neg y)</script></ul> <p>b. <strong>解转换</strong>：</p> <ul><li>若存在大小为 g 的独立集，则每个三角形选且仅选一个顶点（无冲突边保证不选互补文字）。<li>令所选文字为 true（如选 x 则 x=true；选 <mjx-container class=MathJax jax=SVG><svg style="vertical-align: -0.025ex;" viewbox="0 -442 1239 453" focusable=false height=1.025ex role=img width=2.803ex xmlns=http://www.w3.org/2000/svg><g fill=currentColor stroke=currentColor stroke-width=0 transform=scale(1,-1)><g data-mml-node=math><g data-mml-node=mi><path d="M56 323T56 336T70 356H596Q603 353 611 343V102Q598 89 591 89Q587 89 584 90T579 94T575 98T572 102L571 209V316H70Q56 323 56 336Z" data-c=AC></path></g><g data-mml-node=mi transform=translate(667,0)><path d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z" data-c=1D465></path></g></g></g></svg></mjx-container> 则 x=false</ul></ul><ul><li><strong>核心洞察</strong>：<br>独立集选点 = 为每个子句选一个 true 文字，且全局赋值一致。</ul><hr><h4 id=2-INDEPENDENT-SET-→-VERTEX-COVER（顶点覆盖）><a title="2. INDEPENDENT SET → VERTEX COVER（顶点覆盖）" class=headerlink href=#2-INDEPENDENT-SET-→-VERTEX-COVER（顶点覆盖）></a><strong>2. INDEPENDENT SET → VERTEX COVER（顶点覆盖）</strong></h4><ul><li><strong>目标</strong>：将独立集规约到顶点覆盖问题。<li><p><strong>步骤</strong>：<br>a. <strong>实例转换</strong>：</p> <ul><li>给定图 G=(V,E) 和独立集目标 g，直接使用同一图 G<li>设顶点覆盖目标 b = |V| - g（如 |V|=5, g=2 → b=3</ul> <p>b. <strong>解转换</strong>：</p> <ul><li>若存在大小 b 的顶点覆盖 C，则 <script type=math/tex>V \setminus C</script> 是大小为 g 的独立集。<br><em>（因为 C 覆盖所有边 → <script type=math/tex>V \setminus C</script> 内无边）</em><li>若存在大小 g 的独立集 S，则 <script type=math/tex>V \setminus S</script> 是大小为 b 的顶点覆盖。</ul></ul><ul><li><strong>核心洞察</strong>：<br>独立集与顶点覆盖是<strong>互补问题</strong>： <script type="math/tex; mode=display">
S \text{ 是独立集} \iff V \setminus S \text{ 是顶点覆盖}</script></ul><hr><h4 id=3-VERTEX-COVER-→-CLIQUE（团）><a title="3. VERTEX COVER → CLIQUE（团）" class=headerlink href=#3-VERTEX-COVER-→-CLIQUE（团）></a><strong>3. VERTEX COVER → CLIQUE（团）</strong></h4><ul><li><strong>目标</strong>：将顶点覆盖规约到团问题。<li><p><strong>步骤</strong>：<br>a. <strong>实例转换</strong>：</p> <ul><li>给定图 G=(V,E) 和顶点覆盖目标 b，构造其补图 <mjx-container class=MathJax jax=SVG><svg style="vertical-align: -0.05ex;" viewbox="0 -956 786 978" focusable=false height=2.213ex role=img width=1.778ex xmlns=http://www.w3.org/2000/svg><g fill=currentColor stroke=currentColor stroke-width=0 transform=scale(1,-1)><g data-mml-node=math><g data-mjx-texclass=ORD data-mml-node=TeXAtom><g data-mml-node=mover><g data-mml-node=mi><path d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z" data-c=1D43A></path></g><g transform="translate(476.3,266) translate(-250 0)" data-mml-node=mo><path d="M69 544V590H430V544H69Z" data-c=AF></path></g></g></g></g></g></svg></mjx-container><li>设团目标 g = |V| - b（如 |V|=4, b=1 → g=3</ul> <p>b. <strong>解转换</strong>：</p> <ul><li>若 <mjx-container class=MathJax jax=SVG><svg style="vertical-align: -0.05ex;" viewbox="0 -956 786 978" focusable=false height=2.213ex role=img width=1.778ex xmlns=http://www.w3.org/2000/svg><g fill=currentColor stroke=currentColor stroke-width=0 transform=scale(1,-1)><g data-mml-node=math><g data-mjx-texclass=ORD data-mml-node=TeXAtom><g data-mml-node=mover><g data-mml-node=mi><path d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z" data-c=1D43A></path></g><g transform="translate(476.3,266) translate(-250 0)" data-mml-node=mo><path d="M69 544V590H430V544H69Z" data-c=AF></path></g></g></g></g></g></svg></mjx-container> 存在大小为 g 的团 K，则 <script type=math/tex>V \setminus K</script> 是 G 的大小为 b 的顶点覆盖。<br><em>（因 K 在 <mjx-container class=MathJax jax=SVG><svg style="vertical-align: -0.05ex;" viewbox="0 -956 786 978" focusable=false height=2.213ex role=img width=1.778ex xmlns=http://www.w3.org/2000/svg><g fill=currentColor stroke=currentColor stroke-width=0 transform=scale(1,-1)><g data-mml-node=math><g data-mjx-texclass=ORD data-mml-node=TeXAtom><g data-mml-node=mover><g data-mml-node=mi><path d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z" data-c=1D43A></path></g><g transform="translate(476.3,266) translate(-250 0)" data-mml-node=mo><path d="M69 544V590H430V544H69Z" data-c=AF></path></g></g></g></g></g></svg></mjx-container> 中是完全图 → 在 G 中无边 → <mjx-container class=MathJax jax=SVG><svg style="vertical-align: -0.566ex;" viewbox="0 -750 2602.4 1000" focusable=false height=2.262ex role=img width=5.888ex xmlns=http://www.w3.org/2000/svg><g fill=currentColor stroke=currentColor stroke-width=0 transform=scale(1,-1)><g data-mml-node=math><g data-mml-node=mi><path d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z" data-c=1D449></path></g><g data-mml-node=mo transform=translate(991.2,0)><path d="M56 731Q56 740 62 745T75 750Q85 750 92 740Q96 733 270 255T444 -231Q444 -239 438 -244T424 -250Q414 -250 407 -240Q404 -236 230 242T56 731Z" data-c=2216></path></g><g data-mml-node=mi transform=translate(1713.4,0)><path d="M285 628Q285 635 228 637Q205 637 198 638T191 647Q191 649 193 661Q199 681 203 682Q205 683 214 683H219Q260 681 355 681Q389 681 418 681T463 682T483 682Q500 682 500 674Q500 669 497 660Q496 658 496 654T495 648T493 644T490 641T486 639T479 638T470 637T456 637Q416 636 405 634T387 623L306 305Q307 305 490 449T678 597Q692 611 692 620Q692 635 667 637Q651 637 651 648Q651 650 654 662T659 677Q662 682 676 682Q680 682 711 681T791 680Q814 680 839 681T869 682Q889 682 889 672Q889 650 881 642Q878 637 862 637Q787 632 726 586Q710 576 656 534T556 455L509 418L518 396Q527 374 546 329T581 244Q656 67 661 61Q663 59 666 57Q680 47 717 46H738Q744 38 744 37T741 19Q737 6 731 0H720Q680 3 625 3Q503 3 488 0H478Q472 6 472 9T474 27Q478 40 480 43T491 46H494Q544 46 544 71Q544 75 517 141T485 216L427 354L359 301L291 248L268 155Q245 63 245 58Q245 51 253 49T303 46H334Q340 37 340 35Q340 19 333 5Q328 0 317 0Q314 0 280 1T180 2Q118 2 85 2T49 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Z" data-c=1D43E></path></g></g></g></svg></mjx-container> 覆盖 G所有边）</em><li>若 G 存在大小 b 的顶点覆盖 C，则 <mjx-container class=MathJax jax=SVG><svg style="vertical-align: -0.566ex;" viewbox="0 -750 2473.4 1000" focusable=false height=2.262ex role=img width=5.596ex xmlns=http://www.w3.org/2000/svg><g fill=currentColor stroke=currentColor stroke-width=0 transform=scale(1,-1)><g data-mml-node=math><g data-mml-node=mi><path d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z" data-c=1D449></path></g><g data-mml-node=mo transform=translate(991.2,0)><path d="M56 731Q56 740 62 745T75 750Q85 750 92 740Q96 733 270 255T444 -231Q444 -239 438 -244T424 -250Q414 -250 407 -240Q404 -236 230 242T56 731Z" data-c=2216></path></g><g data-mml-node=mi transform=translate(1713.4,0)><path d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z" data-c=1D436></path></g></g></g></svg></mjx-container> 是 <mjx-container class=MathJax jax=SVG><svg style="vertical-align: -0.05ex;" viewbox="0 -956 786 978" focusable=false height=2.213ex role=img width=1.778ex xmlns=http://www.w3.org/2000/svg><g fill=currentColor stroke=currentColor stroke-width=0 transform=scale(1,-1)><g data-mml-node=math><g data-mjx-texclass=ORD data-mml-node=TeXAtom><g data-mml-node=mover><g data-mml-node=mi><path d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z" data-c=1D43A></path></g><g transform="translate(476.3,266) translate(-250 0)" data-mml-node=mo><path d="M69 544V590H430V544H69Z" data-c=AF></path></g></g></g></g></g></svg></mjx-container> 的大小为 g 的团。</ul> <p>c. <strong>无解传递</strong>：</p> <ul><li>若 <mjx-container class=MathJax jax=SVG><svg style="vertical-align: -0.05ex;" viewbox="0 -956 786 978" focusable=false height=2.213ex role=img width=1.778ex xmlns=http://www.w3.org/2000/svg><g fill=currentColor stroke=currentColor stroke-width=0 transform=scale(1,-1)><g data-mml-node=math><g data-mjx-texclass=ORD data-mml-node=TeXAtom><g data-mml-node=mover><g data-mml-node=mi><path d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z" data-c=1D43A></path></g><g transform="translate(476.3,266) translate(-250 0)" data-mml-node=mo><path d="M69 544V590H430V544H69Z" data-c=AF></path></g></g></g></g></g></svg></mjx-container> 无大小为 g 的团，则 G 无大小为 b 的顶点覆盖。</ul><li><p><strong>核心洞察</strong>：<br>顶点覆盖的补集是补图中的团：</p> <script type="math/tex; mode=display">
C \text{ 是顶点覆盖} \iff V \setminus C \text{ 是 } \bar{G} \text{ 中的团}</script></ul><p><img alt="alt text" src=/images/image_66.png><br><img alt="alt text" src=/images/image_67.png><h2 id=Other-Algorithms><a title="Other Algorithms" class=headerlink href=#Other-Algorithms></a>Other Algorithms</h2><h3 id=Euclid’s-Algorithm><a title="Euclid’s Algorithm" class=headerlink href=#Euclid’s-Algorithm></a>Euclid’s Algorithm</h3><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line>Euclid(a, b) </span><br><span class=line>// Input: two integers a and b with a ≥b ≥0</span><br><span class=line>// Output: gcd(a, b)</span><br><span class=line>1. if b = 0 then return a</span><br><span class=line>2. return Euclid(b, a mod b)</span><br><span class=line></span><br><span class=line>extended-Euclid (a, b) </span><br><span class=line>// Input: two integers a and b with a ≥b ≥0</span><br><span class=line>// Output: gcd(a, b) and integers x and y such that ax + by = gcd(a, b)</span><br><span class=line>1. if b = 0 then return (a, 1, 0)</span><br><span class=line>2. (g, x1, y1) = extended-Euclid(b, a mod b)</span><br><span class=line>3. return (g, y1, x1 - (a / b) * y1)</span><br></pre></table></figure><p>For any positive integers a and b ,the extended Euclid algorithm returns integers x , y ,and d such that go <script type=math/tex>d(a, b)=d=a x+b y</script><h3 id=RSA><a class=headerlink href=#RSA title=RSA></a>RSA</h3><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line>1. 随机选择大素数 p, q → 计算 N = p * q</span><br><span class=line>2. 选 e 满足 gcd(e, (p-1)(q-1)) = 1 （互素）</span><br><span class=line>3. 计算 d = e⁻¹ mod (p-1)(q-1)  // 扩展欧几里得（ed ≡ 1 mod φ(n)）</span><br><span class=line>4. 公钥 = (N, e), 私钥 = d</span><br><span class=line></span><br><span class=line>RSA(n, e, m)</span><br><span class=line>// Input: n = p * q, e, m（明文）</span><br><span class=line>// Output: c = m^e mod n</span><br><span class=line></span><br><span class=line>RSA-decrypt(n, d, c)</span><br><span class=line>// Input: n = p * q, d, c</span><br><span class=line>// Output: m = c^d mod n</span><br></pre></table></figure><p>RSA的正确性基于欧拉定理：<p>如果 gcd(m, n) = 1，则 m^φ(n) ≡ 1 (mod n)<h3 id=Prime-Testing><a title="Prime Testing" class=headerlink href=#Prime-Testing></a>Prime Testing</h3><p>费马小定理： 如果 p 是素数且 a 是任意整数，则 a^(p-1) ≡ 1 (mod p)<br><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>primality2(N) </span><br><span class=line>// Input: positive integer N </span><br><span class=line>// Output: yes/no </span><br><span class=line>1. Pick positive integers a1, a2, ..., ak&LTN at random </span><br><span class=line>2. if ai^{N-1} ≡ 1 (mod N ) for all i=1,2, ..., k </span><br><span class=line>then return yes </span><br><span class=line>3. else return no. </span><br></pre></table></figure><br>Pr(primality2 returns yes when N is prime) = 1 <p>Pr(primality2 returns yes when N is not prime) ≤ 1 / 2^k</div><div class=reward-container><div></div><button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div style="display: none;" id=qr><div style="display: inline-block;"><img alt="Hugo 微信支付" src=/images/wechatpay.png><p>微信支付</div><div style="display: inline-block;"><img alt="Hugo 支付宝" src=/images/alipay.png><p>支付宝</div></div></div><div><ul class=post-copyright><li class=post-copyright-author><strong>本文作者： </strong>Hugo<li class=post-copyright-link><strong>本文链接：</strong> <a title="Algorithm：Overall Review" href=http://example.com/2025/06/07/Math/Algorithm/>http://example.com/2025/06/07/Math/Algorithm/</a><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ rel=noopener target=_blank><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</ul></div><footer class=post-footer><div class=post-tags><a href=/tags/Algorithm/ rel=tag># Algorithm</a></div><div class=post-nav><div class=post-nav-item><a href=/2025/05/24/Reading/%E9%87%8D%E5%BB%BA%E9%99%84%E8%BF%91/ rel=prev title=重建附近> <i class="fa fa-chevron-left"></i> 重建附近 </a></div><div class=post-nav-item><a href=/2025/06/09/Technology/%E9%87%8F%E5%AD%90%E7%89%A9%E7%90%86/ rel=next title=量子物理> 量子物理 <i class="fa fa-chevron-right"></i> </a></div></div></footer></article></div><div class=comments id=gitalk-container></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class=sidebar><div class=sidebar-inner><ul class="sidebar-nav motion-element"><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class=nav><li class="nav-item nav-level-2"><a class=nav-link href=#Divide-and-Conquer><span class=nav-number>1.</span> <span class=nav-text>Divide and Conquer</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#Master-theorem><span class=nav-number>1.1.</span> <span class=nav-text>Master theorem:</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#FFT><span class=nav-number>1.2.</span> <span class=nav-text>FFT</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#Graph-Algorithms><span class=nav-number>2.</span> <span class=nav-text>Graph Algorithms</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#DFS><span class=nav-number>2.1.</span> <span class=nav-text>DFS</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#SCC-%EF%BC%88%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%EF%BC%89><span class=nav-number>2.2.</span> <span class=nav-text>SCC （强连通分量）</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#Dijkstra><span class=nav-number>2.3.</span> <span class=nav-text>Dijkstra</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#Bellman-Ford><span class=nav-number>2.4.</span> <span class=nav-text>Bellman-Ford</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#DAG-%E6%9C%80%E7%9F%AD%E8%B7%AF><span class=nav-number>2.5.</span> <span class=nav-text>DAG 最短路</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#MST-%EF%BC%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89><span class=nav-number>2.6.</span> <span class=nav-text>MST （最小生成树）</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#Dynamic-Programming><span class=nav-number>3.</span> <span class=nav-text>Dynamic Programming</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88Dynamic-Programming%EF%BC%89><span class=nav-number>3.1.</span> <span class=nav-text>动态规划（Dynamic Programming）</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#LIS%EF%BC%88%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%89><span class=nav-number>3.2.</span> <span class=nav-text>LIS（最长递增子序列）</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#LCS-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97><span class=nav-number>3.3.</span> <span class=nav-text>LCS(最长公共子序列)</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98><span class=nav-number>3.4.</span> <span class=nav-text>01背包问题</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#Linear-Programming><span class=nav-number>4.</span> <span class=nav-text>Linear Programming</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#MAX-Flow><span class=nav-number>4.1.</span> <span class=nav-text>MAX Flow</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#Simplex><span class=nav-number>4.2.</span> <span class=nav-text>Simplex</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#Dual-LP><span class=nav-number>4.3.</span> <span class=nav-text>Dual LP</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#P-vs-NP><span class=nav-number>5.</span> <span class=nav-text>P vs NP</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#NP-Complete><span class=nav-number>5.1.</span> <span class=nav-text>NP-Complete</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#Reductions><span class=nav-number>6.</span> <span class=nav-text>Reductions</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%A7%84%E7%BA%A6%E9%93%BE%E5%88%86%E6%9E%90%EF%BC%9A3SAT-%E2%86%92-INDEPENDENT-SET-%E2%86%92-VERTEX-COVER-%E2%86%92-CLIQUE><span class=nav-number>6.1.</span> <span class=nav-text>规约链分析：3SAT → INDEPENDENT SET → VERTEX COVER → CLIQUE</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-3SAT-%E2%86%92-INDEPENDENT-SET%EF%BC%88%E7%8B%AC%E7%AB%8B%E9%9B%86%EF%BC%89><span class=nav-number>6.1.1.</span> <span class=nav-text>1. 3SAT → INDEPENDENT SET（独立集）</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-INDEPENDENT-SET-%E2%86%92-VERTEX-COVER%EF%BC%88%E9%A1%B6%E7%82%B9%E8%A6%86%E7%9B%96%EF%BC%89><span class=nav-number>6.1.2.</span> <span class=nav-text>2. INDEPENDENT SET → VERTEX COVER（顶点覆盖）</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-VERTEX-COVER-%E2%86%92-CLIQUE%EF%BC%88%E5%9B%A2%EF%BC%89><span class=nav-number>6.1.3.</span> <span class=nav-text>3. VERTEX COVER → CLIQUE（团）</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#Other-Algorithms><span class=nav-number>7.</span> <span class=nav-text>Other Algorithms</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#Euclid%E2%80%99s-Algorithm><span class=nav-number>7.1.</span> <span class=nav-text>Euclid’s Algorithm</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#RSA><span class=nav-number>7.2.</span> <span class=nav-text>RSA</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#Prime-Testing><span class=nav-number>7.3.</span> <span class=nav-text>Prime Testing</span></a></ol></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=Hugo class=site-author-image itemprop=image src=/images/avatar.png><p class=site-author-name itemprop=name>Hugo<div class=site-description itemprop=description>古之成大事者，不惟有超世之才，亦必有坚韧不拔之志。</div></div><div class="site-state-wrap motion-element"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>60</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>12</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>34</span> <span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class=links-of-author-item> <a title="GitHub → https://github.com/Hugo0713" href=https://github.com/Hugo0713 rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class=links-of-author-item> <a title="E-Mail → mailto:hugo0713@sjtu.edu.cn" href=mailto:hugo0713@sjtu.edu.cn rel=noopener target=_blank><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class=links-of-author-item> <a title="QQ → tencent://message/?uin=2379727289" href=tencent://message/?uin=2379727289 rel=noopener target=_blank><i class="fab fa-qq fa-fw"></i>QQ</a> </span><span class=links-of-author-item> <a title="WeChat → weixin://dl/chat?HUGO--2025" href=weixin://dl/chat?HUGO--2025 rel=noopener target=_blank><i class="fab fa-weixin fa-fw"></i>WeChat</a> </span><span class=links-of-author-item> <a title="Zhihu → https://www.zhihu.com/people/tong-ming-yun-bu-ji" href=https://www.zhihu.com/people/tong-ming-yun-bu-ji rel=noopener target=_blank><i class="fab fa-zhihu fa-fw"></i>Zhihu</a> </span><span class=links-of-author-item> <a title="Bilibili → https://space.bilibili.com/415423619?spm_id_from=333.788.0.0" href=https://space.bilibili.com/415423619?spm_id_from=333.788.0.0 rel=noopener target=_blank><i class="fas fa-tv-retro fa-fw"></i>Bilibili</a> </span></div><div class="links-of-blogroll motion-element"><div class=links-of-blogroll-title><i class="fa fa-link fa-fw"></i> 好用的网站</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://csdiy.wiki/ rel=noopener target=_blank title=https://csdiy.wiki>csdiy</a><li class=links-of-blogroll-item><a href=https://opencs.app/ rel=noopener target=_blank title=https://opencs.app>opencs</a><li class=links-of-blogroll-item><a href=https://csrankings.org/ rel=noopener target=_blank title=https://csrankings.org>csrankings</a></ul></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i><span>0%</span></div></div></aside><div id=sidebar-dimmer></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© <span itemprop=copyrightYear>2025</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>Hugo</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-chart-area"></i> </span><span title=站点总字数>175k</span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-coffee"></i> </span><span title=站点阅读时长>2:39</span></div><div class=footer-custom><div class=acknowledgment>Background photo by Shirley</div></div><div class=powered-by>由 <a class=theme-link href=https://hexo.io/ rel=noopener target=_blank>Hexo</a> & <a class=theme-link href=https://theme-next.org/ rel=noopener target=_blank>NexT.Gemini</a> 强力驱动</div><br><script async src=http://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js></script><span id=busuanzi_container_site_pv>总访问量<span id=busuanzi_value_site_pv></span>次</span><span class=post-meta-divider>|</span><span id=busuanzi_container_site_uv>总访客数<span id=busuanzi_value_site_uv></span>人</span><!-- 不蒜子计数初始值纠正 --><script>$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
});</script><div class=busuanzi-count><script async src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><span style="display: none;" class=post-meta-item id=busuanzi_container_site_uv> <span class=post-meta-item-icon> <i class="fa fa-user"></i> </span> <span class=site-uv title=总访客量> <span id=busuanzi_value_site_uv></span> </span> </span><span class=post-meta-divider>|</span><span style="display: none;" class=post-meta-item id=busuanzi_container_site_pv> <span class=post-meta-item-icon> <i class="fa fa-eye"></i> </span> <span class=site-pv title=总访问量> <span id=busuanzi_value_site_pv></span> </span> </span></div></div></footer></div><script src=/lib/anime.min.js></script><script src=/lib/velocity/velocity.min.js></script><script src=/lib/velocity/velocity.ui.min.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/schemes/pisces.js></script><script src=/js/next-boot.js></script><script src=/js/bookmark.js></script><script src=/js/local-search.js></script><script>if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }</script><link href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css rel=stylesheet><script>NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'Ov23li9o2o2qxTETe12J',
      clientSecret: '2a663bc459fc3e3df8c5a88e4753a7d0148034f3',
      repo        : 'blog-comments',
      owner       : 'Hugo0713',
      admin       : ['Hugo0713'],
      id          : 'd3a3d54a45d8f01e4105af2fa11958fc',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});</script>